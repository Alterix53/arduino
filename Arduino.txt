// #include <WiFi.h>
// #include <PubSubClient.h>
#include <ESP32Servo.h>
// #include "DHT.h"

// // --- WIFI & MQTT ---
// const char* ssid = "Huy Duy";
// const char* password = "Vietnam060512";
// const char* mqtt_server = "broker.hivemq.com";

// // --- TOPIC ---
// const char* topic_temp = "smartdoor/nhom10/temperature";
// const char* topic_hum  = "smartdoor/nhom10/humidity";
// const char* topic_st_door   = "smartdoor/nhom10/status/door";
// const char* topic_st_buzzer = "smartdoor/nhom10/status/buzzer";
// const char* topic_st_sensor = "smartdoor/nhom10/status/sensor";
// const char* topic_cmd = "smartdoor/nhom10/cmd";

// WiFiClient espClient;
// PubSubClient client(espClient);

// // --- PHẦN CỨNG ---
// #define SERVO_PIN 13
// #define TRIG_PIN  5 
// #define ECHO_PIN  18 
// #define DHT_PIN   15
// #define BUZZER_PIN 4
// #define LED_PIN    2    // <--- Chân đèn cảnh báo mới
// #define DHT_TYPE DHT22

// Servo doorLock;
// DHT dht(DHT_PIN, DHT_TYPE);

// // --- BIẾN TOÀN CỤC ---
// unsigned long lastMsg = 0;
// unsigned long doorOpenTime = 0; 
// unsigned long previousBlink = 0; // Biến để đếm giờ chớp đèn
// bool isDoorOpen = false;
// bool ledState = LOW; // Trạng thái hiện tại của đèn (Tắt/Bật)

// // Cấu hình (Mặc định)
// bool isSensorActive = true;     
// int tempThreshold = 40;
// int distThreshold = 50; // <--- Ngưỡng khoảng cách mặc định (cm)
// bool isBuzzerManual = false; 

// void setup() {
//   Serial.begin(115200);
//   doorLock.attach(SERVO_PIN);
//   doorLock.write(0);
  
//   pinMode(TRIG_PIN, OUTPUT);
//   pinMode(ECHO_PIN, INPUT);
//   dht.begin();
//   pinMode(BUZZER_PIN, OUTPUT);
//   pinMode(LED_PIN, OUTPUT); // <--- Khởi tạo đèn

//   setup_wifi();
//   client.setServer(mqtt_server, 1883);
//   client.setCallback(callback);
// }

// void setup_wifi() {
//   delay(10);
//   WiFi.begin(ssid, password);
//   while (WiFi.status() != WL_CONNECTED) {
//     delay(500); Serial.print(".");
//   }
// }

// void callback(char* topic, byte* message, unsigned int length) {
//   String msg;
//   for (int i = 0; i < length; i++) msg += (char)message[i];
//   Serial.print("Lenh: "); Serial.println(msg);

//   if (msg == "OPEN") {
//     for (int i=0;i<=90;i++)
//     {
//       doorLock.write(i);
//       delay(10);
//     } 
//     isDoorOpen = true; 
//     doorOpenTime = millis();
//     client.publish(topic_st_door, "Đang Mở");
//   } 
//   else if (msg == "CLOSE") {
//     for (int i=0;i<=90;i++)
//     {
//       doorLock.write(90-i);
//       delay(10);
//     }  
//     isDoorOpen = false;
//     client.publish(topic_st_door, "Đang Khóa");
//   }
//   else if (msg == "BUZZER_ON") {
//     isBuzzerManual = true; tone(BUZZER_PIN, 1000);
//     client.publish(topic_st_buzzer, "Đang Kêu");
//   }
//   else if (msg == "BUZZER_OFF") {
//     isBuzzerManual = false; noTone(BUZZER_PIN); 
//     client.publish(topic_st_buzzer, "Yên Lặng");
//   }
//   else if (msg == "SENSOR_ON") {
//     isSensorActive = true; client.publish(topic_st_sensor, "Đang Bật");
//   }
//   else if (msg == "SENSOR_OFF") {
//     isSensorActive = false; client.publish(topic_st_sensor, "Đã Tắt");
//   }
//   else if (msg.startsWith("SET_TEMP:")) {
//     tempThreshold = msg.substring(9).toInt();
//   }
//   // --- NHẬN LỆNH CÀI ĐẶT KHOẢNG CÁCH ---
//   else if (msg.startsWith("SET_DIST:")) {
//     distThreshold = msg.substring(9).toInt();
//     Serial.println("New Dist Limit: " + String(distThreshold));
//   }
// }

// void reconnect() {
//   while (!client.connected()) {
//     if (client.connect("ESP32_Nhom10_Main")) {
//       client.subscribe(topic_cmd);
//       client.publish(topic_st_door, "Đang Khóa");
//     } else delay(5000);
//   }
// }

// void loop() {
//   if (!client.connected()) reconnect();
//   client.loop();

//   // Auto-Lock
//   if (isDoorOpen && (millis() - doorOpenTime > 5000)) {
//     for (int i=0;i<=90;i++)
//     {
//       doorLock.write(90-i); 
//       isDoorOpen = false;
//     }
//     client.publish(topic_st_door, "Đang Khóa (Auto)");
//   }

//   // --- LOGIC ĐỌC CẢM BIẾN & XỬ LÝ LIÊN TỤC ---
//   // Đọc siêu âm (Không được dùng delay trong này để đèn còn chớp)
//   int distance = getDistance(TRIG_PIN,ECHO_PIN);
//   // // LOGIC ĐÈN CHỚP TẮT (BLINK) KHI CÓ NGƯỜI
//   // if (distance > 0 && distance < distThreshold) {
//   //     // Dùng millis để chớp tắt mỗi 200ms
//   //     if (millis() - previousBlink >= 200) {
//   //       previousBlink = millis();
//   //       ledState = !ledState; // Đảo trạng thái đèn
//   //       digitalWrite(LED_PIN, ledState);
//   //     }
//   // } else {
//   //     digitalWrite(LED_PIN, LOW); // Tắt hẳn nếu không có người
//   // }

//   // Gửi dữ liệu định kỳ (2 giây/lần)
//   long now = millis();
//   if (now - lastMsg > 2000) {
//     lastMsg = now;
//     if (isSensorActive) {
//       float h = dht.readHumidity();
//       float t = dht.readTemperature();
//       if (!isnan(t) && !isnan(h)) {
//         client.publish(topic_temp, String(t, 1).c_str());
//         client.publish(topic_hum, String(h, 1).c_str());
        
//         // Buzzer Logic
//         if (isBuzzerManual) tone(BUZZER_PIN, 1000);
//         else if (t > tempThreshold) {
//            tone(BUZZER_PIN, 1000);
//            client.publish(topic_st_buzzer, "Cảnh Báo Nhiệt!");
//         } else {
//            noTone(BUZZER_PIN);
//            client.publish(topic_st_buzzer, "Yên Lặng");
//         }
//       }
//     }
//   }
// }


// int getDistance(int trigPin, int echoPin) {
//   digitalWrite(trigPin, LOW); delayMicroseconds(2);
//   digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW);
//   long duration = pulseIn(echoPin, HIGH, 30000);
//   int distance = duration * 0.034 / 2;
//   return distance;
// }



// Servo myservo;
// int trigPin = 18;
// int echoPin = 5;
// int dhtPin = 111;
// DHT dht(dhtPin, DHT11);

// void setup() {
//   myservo.attach(17);
//   pinMode(trigPin, OUTPUT);
//   pinMode(echoPin, INPUT);
//   //dht.begin();
//   Serial.begin(9600);
// }
// void runServo() {
//   for (int i = 0; i < 90; i++) {
//     myservo.write(i);
//     delay(10);
//   }
//     for (int i = 0; i < 90; i++) {
//     myservo.write(90 - i);
//     delay(10);
//   }
// }
// void loop() {

//   // test servo.

//   myservo.write(0);

//   // test khoảng cách
//   int dis = getDistance(trigPin, echoPin);
//   Serial.println(dis);
//   // if (dis <= 1) {
//   //   runServo();
//   // }
//   delay(300);
// }



// #include <Wire.h>
// #include <LiquidCrystal_I2C.h>

// // Địa chỉ I2C thường của LCD: 0x27 hoặc 0x3F
// LiquidCrystal_I2C lcd(0x27, 16, 2);  

// void setup() {
//   Wire.begin(21, 22);    // SDA = 21, SCL = 22 (chuẩn ESP32)
  
//   lcd.init();            // Khởi tạo LCD
//   lcd.backlight();       // Bật đèn nền
//   lcd.clear();

//   lcd.setCursor(0, 0);
//   lcd.print("ESP32 LCD Test");
  
//   lcd.setCursor(0, 1);
//   lcd.print("Hello World!");
// }

// void loop() {
//   // Nhấp nháy ký tự để test refresh
//   lcd.setCursor(15, 1);
//   lcd.print("*");
//   delay(500);
//   lcd.setCursor(15, 1);
//   lcd.print(" ");
//   delay(500);
// }

// #include <DHT.h>
// #include <DHT_U.h>

// #define DHTPIN 4         // chân kết nối DHT
// #define DHTTYPE DHT11    // DHT22 hoặc DHT11

// DHT dht(DHTPIN, DHTTYPE);
// Servo s;
// void setup() {
//   Serial.begin(9600);
//   dht.begin();
//   Serial.println("DHT Test ESP32");
//   s.attach(17);
// }

// void loop() {
//   delay(2000);  // Không được đo quá nhanh
//   for (int i = 0; i < 70; i++) {
//     s.write(70-i);
//     delay(5);
//   }
//   for (int i = 0; i < 70; i++) {
//     s.write(i);
//     delay(5);
//   }
//   delay(30000);
//   float h = dht.readHumidity();
//   float t = dht.readTemperature();

//   if (isnan(h) || isnan(t)) {
//     Serial.println("❌ Loi doc DHT !");
//     return;
//   }

//   Serial.print("Nhiet do: ");
//   Serial.print(t);
//   Serial.print(" *C   |   ");

//   Serial.print("Do am: ");
//   Serial.print(h);
//   Serial.println(" %");
// }


#define BUZZER 25

void setup() {
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);
}

void loop() {
  // Bật buzzer
  delay(1000);
  digitalWrite(BUZZER,HIGH);
  delay(1000);
  digitalWrite(BUZZER,LOW);
  delay(1000);
}

