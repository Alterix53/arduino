#include <WiFi.h>
#include <PubSubClient.h>
#include <ESP32Servo.h>
#include "DHT.h"
#include <LiquidCrystal_I2C.h> // <--- Thư viện LCD

// --- 1. CẤU HÌNH WIFI & MQTT ---
const char* ssid = "Alterix";
const char* password = "12345679";
const char* mqtt_server = "broker.hivemq.com";

// --- TOPIC ---
// Topic gửi lên (publish)
const char* topic_temp = "smartdoor/nhom10/temperature";
const char* topic_hum  = "smartdoor/nhom10/humidity";
const char* topic_st_door   = "smartdoor/nhom10/status/door";
const char* topic_st_buzzer = "smartdoor/nhom10/status/buzzer";
const char* topic_st_sensor = "smartdoor/nhom10/status/sensor";
const char* topic_alert     = "smartdoor/nhom10/alert"; // Topic gửi cảnh báo Pushsaferm

// Topic nhận lệnh (Subscribe)
const char* topic_cmd = "smartdoor/nhom10/cmd"; // Lệnh điều khiển
const char* topic_lcd = "smartdoor/nhom10/lcd"; // Lệnh hiển thị chữ lên LCD

WiFiClient espClient;
PubSubClient client(espClient);

// --- PHẦN CỨNG ---
#define TRIG_PIN  18
#define ECHO_PIN  5 
#define DHT_PIN   15
#define BUZZER_PIN 25
#define LED_PIN    2    // <--- Chân đèn cảnh báo mới
#define DHT_TYPE DHT11

int servoPin = 17;

Servo doorLock;
DHT dht(DHT_PIN, DHT_TYPE);


// --- BIẾN TOÀN CỤC ---
unsigned long lastMsg = 0;
unsigned long doorOpenTime = 0; 
unsigned long previousBlink = 0; // Biến để đếm giờ chớp đèn
bool isDoorOpen = false;
bool ledState = LOW; // Trạng thái hiện tại của đèn (Tắt/Bật)
int lastTime = 0;
unsigned long lastAlertTime = 0; // Biến chống spam tin nhắn Pushsafer
int distance = 0;//khoảng cách

// Khởi tạo LCD địa chỉ 0x27, 16 cột 2 dòng
LiquidCrystal_I2C lcd(0x27, 16, 2);

// Cấu hình (Mặc định)
bool isSensorActive = false;     
int tempThreshold = 60; // Ngưỡng nhiệt độ báo động
int distThreshold = 5; // Ngưỡng khoảng cách báo động (cm)
bool isBuzzerManual = false; 
float t = 0;

void setup() {
  // Khởi tạo LCD
  lcd.init();
  lcd.backlight();
  lcd.setCursor(0, 0);
  lcd.print("SmartDoor Init...");

  // serial
  Serial.begin(115200);
  doorLock.attach(servoPin);
  doorLock.write(0); // Mặc định khóa
  
  // Khởi tạo Pin
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  dht.begin();
  pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT); // <--- Khởi tạo đèn

  // Kết nối mạng
  setup_wifi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);
  lastTime = millis();

  digitalWrite(BUZZER_PIN, LOW);

}

void setup_wifi() {
  delay(10);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500); Serial.print(".");
  }
}

// --- XỬ LÝ LỆNH TỪ NODE-RED GỬI XUỐNG ---
void callback(char* topic, byte* message, unsigned int length) {
  String msg;
  for (int i = 0; i < length; i++) msg += (char)message[i];
  Serial.print("Topic: "); Serial.print(topic);
  Serial.print(" | Msg: "); Serial.println(msg);

  // 1. XỬ LÝ TIN NHẮN HIỂN THỊ LCD
  if (String(topic) == topic_lcd) {
      // KIỂM TRA: Nếu tin nhắn bắt đầu bằng "GREET:" (Là tin chào hỏi)
      if (msg.startsWith("GREET:")) {
          String name = msg.substring(6); // Cắt bỏ chữ "GREET:" lấy cái tên phía sau
          
          lcd.clear();
          // Dòng 1: Cố định
          lcd.setCursor(0, 0); 
          lcd.print("Welcome Home !");
          
          // Dòng 2: Hiển thị tên (Canh giữa cho đẹp nếu thích)
          lcd.setCursor(0, 1); 
          lcd.print(name); 
      } 
      // Nếu là tin nhắn bình thường (không có GREET)
      else {
          lcd.clear();
          lcd.setCursor(0, 0);
          lcd.print(msg); 
      }
  }
  // 2. xử lý các lệnh mở, đóng khác nhau (các lệnh điều khiển)
  if (String(topic) == topic_cmd) {
    if (msg == "OPEN") {
        for (int i=0;i<=70;i++)
        {
          doorLock.write(i);
          delay(10);
        } 
        isDoorOpen = true; 
        doorOpenTime = millis();
        client.publish(topic_st_door, "Đang Mở");
        // Khi mở cửa bằng nút, cũng có thể hiện câu chào mặc định
        lcd.clear(); lcd.setCursor(0,0); lcd.print("Welcome Home !");
      } 
      else if (msg == "CLOSE" &&  isDoorOpen) {
        for (int i=0;i<=70;i++)
        {
          doorLock.write(70-i);
          delay(10);
        }  
        isDoorOpen = false;
        client.publish(topic_st_door, "Đang Khóa");
        lcd.clear(); lcd.setCursor(0,0); lcd.print("Door Locked");
      }
      else if (msg == "BUZZER_ON") {
        isBuzzerManual = true; 
        Serial.println("buzzer dang bat");
        client.publish(topic_st_buzzer, "Đang Kêu");
      }
      else if (msg == "BUZZER_OFF") {
        isBuzzerManual = false; 
        client.publish(topic_st_buzzer, "Yên Lặng");
      }
      else if (msg == "SENSOR_ON") {
        isSensorActive = true; client.publish(topic_st_sensor, "Đang Bật");
      }
      else if (msg == "SENSOR_OFF") {
        isSensorActive = false; client.publish(topic_st_sensor, "Đã Tắt");
      }
      // Cập nhật ngưỡng cài đặt
      else if (msg.startsWith("SET_TEMP:")) {
        tempThreshold = msg.substring(9).toInt();
        Serial.println("New Temp Limit: " + String(tempThreshold));
      }
      // --- NHẬN LỆNH CÀI ĐẶT KHOẢNG CÁCH ---
      else if (msg.startsWith("SET_DIST:")) {
        distThreshold = msg.substring(9).toInt();
        Serial.println("New Dist Limit: " + String(distThreshold)); // 
      }
  }
 
}

void reconnect() {
  while (!client.connected()) {
    if (client.connect("ESP32_Nhom10_Main")) {
      // Đăng ký nhận tin từ cả 2 topic
      client.subscribe(topic_cmd); // Topic lệnh
      client.subscribe(topic_lcd); // Topic hiển thị LCD
      
      client.publish(topic_st_door, "Đang Khóa");
      lcd.clear(); lcd.print("System Ready!");
    } else delay(5000);
  }
}


// VÒNG LẶP CHÍNH
void loop() {
  if (!client.connected()) reconnect();
  client.loop();

  // 1. TỰ ĐỘNG KHÓA CỬA (AUTO-LOCK)
  if (isDoorOpen && (millis() - doorOpenTime > 5000)) {
    for (int i=0;i<=70;i++)
    {
      doorLock.write(70-i); 
      isDoorOpen = false;
      delay(10);
    }
    client.publish(topic_st_door, "Đang Khóa (Auto)");
   
  }

  // --- LOGIC ĐỌC CẢM BIẾN & XỬ LÝ LIÊN TỤC ---
  // Đọc siêu âm (Không được dùng delay trong này để đèn còn chớp)
  int distanceNow = millis();
  if (distanceNow - lastTime >= 2000) {
    distance = getDistance(TRIG_PIN,ECHO_PIN); Serial.println(distance);
    lastTime = distanceNow; 
  }

  // LOGIC ĐÈN CHỚP TẮT (BLINK) KHI CÓ NGƯỜI
  if (distance > 0 && distance < distThreshold) {

      // a. Đèn LED chớp tắt (Cảnh báo tại chỗ)
      if (millis() - previousBlink >= 250) {
        previousBlink = millis();
        ledState = !ledState; // Đảo trạng thái đèn
        digitalWrite(LED_PIN, ledState);
      }
      // b. Gửi cảnh báo PUSHSAFER (Cảnh báo từ xa)
      // Chỉ gửi 15 giây/lần để tránh spam điện thoại
      if (millis() - lastAlertTime > 15000) {
          lastAlertTime = millis();

          client.publish(topic_alert, "Co nguoi la");
          Serial.println(">> SENT PUSHSAFER ALERT!");
      }
  } else {
      digitalWrite(LED_PIN, LOW); // Tắt hẳn nếu không có người
  }

  // 3. Gửi dữ liệu định kỳ (2 giây/lần)
  long now = millis();
  if (now - lastMsg > 2000) {
    lastMsg = now;
    if (isSensorActive) {
      float h = dht.readHumidity();
      t = dht.readTemperature();
      Serial.println(h); Serial.println(t);
      if (!isnan(t) && !isnan(h)) {
        // gửi dữ liệu lên sv
        client.publish(topic_temp, String(t, 1).c_str());
        client.publish(topic_hum, String(h, 1).c_str());
      }

    }
    // Buzzer Logic
    // chỉ kêu nếu giá trị nhiệt độ vượt ngưỡng và web đang bật buzzer
    if ((int)t > tempThreshold && isBuzzerManual == true) {
      Serial.println("canh bao canh bao");
      digitalWrite(BUZZER_PIN, HIGH);

      client.publish(topic_st_buzzer, "Cảnh Báo Nhiệt!");

      // Có thể hiển thị cảnh báo lên LCD nếu muốn
      // lcd.setCursor(0,1); lcd.print("WARNING: HOT!"); 
    } else {
      digitalWrite(BUZZER_PIN, LOW);
      client.publish(topic_st_buzzer, "Yên Lặng");
    }
  }
}


int getDistance(int trigPin, int echoPin) {
  digitalWrite(trigPin, LOW); delayMicroseconds(2);
  digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW);
  long duration = pulseIn(echoPin, HIGH, 30000);
  int distance = duration * 0.034 / 2;
  return distance;
}


